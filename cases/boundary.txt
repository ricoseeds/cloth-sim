// boundary case
    // HalfEdge *begin = Vertices[0]->edge;
    // std::cout << "Id of the HE  : " << begin->id << std::endl;
    // HalfEdge *t = begin;
    // bool boundary_flag = false;
    // do
    // {
    //     std::cout << t->face->id << "\n";
    //     // order of these next two statement, matters
    //     if (t->boundary)
    //     {
    //         boundary_flag = true;
    //         break;
    //     }
    //     t = t->pairHalfEdge->nextHalfEdge;

    // } while (t != begin);
    // if (boundary_flag)
    // {
    //     std::cout << "Boundary detected";
    // }





    mymesh->perform_cut(glm::vec2(-0.5, 2.8), glm::vec2(2.3, -2.0));

//face
    HalfEdge *begin = Faces[0]->start_edge;
    std::cout << "Id of the HE  : " << begin->id << std::endl;
    HalfEdge *t = begin;
    bool boundary_flag = false;
    do
    {
        // std::cout << t->face->id << "\n";
        std::cout << t->vertex->id << " ";
        t = t->nextHalfEdge;

    } while (t != begin);

//all connections tested
HalfEdge *begin = Faces[5]->start_edge;
    std::cout << "Face[0] id : " << Faces[5]->id << std::endl;
    HalfEdge *t = begin;
    std::cout << t->id << std::endl;
    std::cout << t->nextHalfEdge->id << std::endl;
    std::cout << t->nextHalfEdge->nextHalfEdge->id << std::endl;
    std::cout << t->nextHalfEdge->nextHalfEdge->nextHalfEdge->id << std::endl; // shouldbe same as t -> id
    std::cout << "------\n";
    std::cout << t->id << std::endl;
    std::cout << t->prevHalfEdge->id << std::endl;
    std::cout << t->prevHalfEdge->prevHalfEdge->id << std::endl;
    std::cout << t->prevHalfEdge->prevHalfEdge->prevHalfEdge->id << std::endl; // shouldbe same as t -> id
    std::cout << "------\n";
    std::cout << glm::to_string(t->vertex->position) << std::endl;
    std::cout << glm::to_string(t->nextHalfEdge->vertex->position) << std::endl;
    std::cout << glm::to_string(t->nextHalfEdge->nextHalfEdge->vertex->position) << std::endl;
    std::cout << glm::to_string(t->nextHalfEdge->nextHalfEdge->nextHalfEdge->vertex->position) << std::endl; // shouldbe same as t -> id
    std::cout << "------\n";
    std::cout << glm::to_string(t->vertex->position) << std::endl;
    std::cout << glm::to_string(t->prevHalfEdge->vertex->position) << std::endl;
    std::cout << glm::to_string(t->prevHalfEdge->prevHalfEdge->vertex->position) << std::endl;
    std::cout << glm::to_string(t->prevHalfEdge->prevHalfEdge->prevHalfEdge->vertex->position) << std::endl; // shouldbe same as t -> id
    std::cout << "id Opposite to he 6 : " << t->nextHalfEdge->nextHalfEdge->pairHalfEdge->id << "\n";
 
 
 
 
 //deducing faces

   // if (begin_cut->pairHalfEdge != NULL)
    // {
    //     std::cout << begin_cut->pairHalfEdge->face->id;
    // }
    // if (begin_cut->nextHalfEdge->pairHalfEdge != NULL)
    // {
    //     std::cout << begin_cut->nextHalfEdge->pairHalfEdge->face->id;
    // }
    // if (begin_cut->nextHalfEdge->nextHalfEdge->pairHalfEdge != NULL)
    // {
    //     std::cout << begin_cut->nextHalfEdge->nextHalfEdge->pairHalfEdge->face->id;
    // }

    // if (first_point_found)
    // {
    //     std::cout << " Id of the face in which the point is : " << begin_cut->face->id << "\n";
    // }
    // if (last_point_found)
    // {
    //     std::cout << " Id of the face in which the point is : " << last_he->face->id << "\n";
    // }