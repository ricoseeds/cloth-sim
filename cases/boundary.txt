// boundary case
    // HalfEdge *begin = Vertices[0]->edge;
    // std::cout << "Id of the HE  : " << begin->id << std::endl;
    // HalfEdge *t = begin;
    // bool boundary_flag = false;
    // do
    // {
    //     std::cout << t->face->id << "\n";
    //     // order of these next two statement, matters
    //     if (t->boundary)
    //     {
    //         boundary_flag = true;
    //         break;
    //     }
    //     t = t->pairHalfEdge->nextHalfEdge;

    // } while (t != begin);
    // if (boundary_flag)
    // {
    //     std::cout << "Boundary detected";
    // }





    mymesh->perform_cut(glm::vec2(-0.5, 2.8), glm::vec2(2.3, -2.0));

//face
    HalfEdge *begin = Faces[0]->start_edge;
    std::cout << "Id of the HE  : " << begin->id << std::endl;
    HalfEdge *t = begin;
    bool boundary_flag = false;
    do
    {
        // std::cout << t->face->id << "\n";
        std::cout << t->vertex->id << " ";
        t = t->nextHalfEdge;

    } while (t != begin);

//all connections tested
HalfEdge *begin = Faces[5]->start_edge;
    std::cout << "Face[0] id : " << Faces[5]->id << std::endl;
    HalfEdge *t = begin;
    std::cout << t->id << std::endl;
    std::cout << t->nextHalfEdge->id << std::endl;
    std::cout << t->nextHalfEdge->nextHalfEdge->id << std::endl;
    std::cout << t->nextHalfEdge->nextHalfEdge->nextHalfEdge->id << std::endl; // shouldbe same as t -> id
    std::cout << "------\n";
    std::cout << t->id << std::endl;
    std::cout << t->prevHalfEdge->id << std::endl;
    std::cout << t->prevHalfEdge->prevHalfEdge->id << std::endl;
    std::cout << t->prevHalfEdge->prevHalfEdge->prevHalfEdge->id << std::endl; // shouldbe same as t -> id
    std::cout << "------\n";
    std::cout << glm::to_string(t->vertex->position) << std::endl;
    std::cout << glm::to_string(t->nextHalfEdge->vertex->position) << std::endl;
    std::cout << glm::to_string(t->nextHalfEdge->nextHalfEdge->vertex->position) << std::endl;
    std::cout << glm::to_string(t->nextHalfEdge->nextHalfEdge->nextHalfEdge->vertex->position) << std::endl; // shouldbe same as t -> id
    std::cout << "------\n";
    std::cout << glm::to_string(t->vertex->position) << std::endl;
    std::cout << glm::to_string(t->prevHalfEdge->vertex->position) << std::endl;
    std::cout << glm::to_string(t->prevHalfEdge->prevHalfEdge->vertex->position) << std::endl;
    std::cout << glm::to_string(t->prevHalfEdge->prevHalfEdge->prevHalfEdge->vertex->position) << std::endl; // shouldbe same as t -> id
    std::cout << "id Opposite to he 6 : " << t->nextHalfEdge->nextHalfEdge->pairHalfEdge->id << "\n";
 
 
 
 
 //deducing faces

   // if (begin_cut->pairHalfEdge != NULL)
    // {
    //     std::cout << begin_cut->pairHalfEdge->face->id;
    // }
    // if (begin_cut->nextHalfEdge->pairHalfEdge != NULL)
    // {
    //     std::cout << begin_cut->nextHalfEdge->pairHalfEdge->face->id;
    // }
    // if (begin_cut->nextHalfEdge->nextHalfEdge->pairHalfEdge != NULL)
    // {
    //     std::cout << begin_cut->nextHalfEdge->nextHalfEdge->pairHalfEdge->face->id;
    // }

    // if (first_point_found)
    // {
    //     std::cout << " Id of the face in which the point is : " << begin_cut->face->id << "\n";
    // }
    // if (last_point_found)
    // {
    //     std::cout << " Id of the face in which the point is : " << last_he->face->id << "\n";
    // }



     for (auto face : indices)
    {
        MeshFace *newFace = new MeshFace(face_count);
        std::pair<int, int> edge1;
        std::pair<int, int> edge2;
        std::pair<int, int> edge3;
        edge1 = std::make_pair(std::get<0>(face), std::get<1>(face));
        edge2 = std::make_pair(std::get<1>(face), std::get<2>(face));
        edge3 = std::make_pair(std::get<2>(face), std::get<0>(face));
        Edges[edge1] = std::move(new HalfEdge(he_count));
        Edges[edge1]->edge_pair = edge1;
        Edges[edge2] = std::move(new HalfEdge(he_count + 1));
        Edges[edge2]->edge_pair = edge2;
        Edges[edge3] = std::move(new HalfEdge(he_count + 2));
        Edges[edge3]->edge_pair = edge3;
        he_count += 3;
        newFace->start_edge = Edges[edge1];
        // perform the next edge connection
        Edges[edge1]->nextHalfEdge = Edges[edge2];
        Edges[edge2]->nextHalfEdge = Edges[edge3];
        Edges[edge3]->nextHalfEdge = Edges[edge1];
        // perform prev edge connection
        Edges[edge1]->prevHalfEdge = Edges[edge3];
        Edges[edge3]->prevHalfEdge = Edges[edge2];
        Edges[edge2]->prevHalfEdge = Edges[edge1];
        // halfedge pointing to vertices
        Edges[edge1]->vertex = Vertices[std::get<0>(face) - 1];
        Edges[edge2]->vertex = Vertices[std::get<1>(face) - 1];
        Edges[edge3]->vertex = Vertices[std::get<2>(face) - 1];
        // halfedge pointing to faces
        Edges[edge1]->face = newFace;
        Edges[edge2]->face = newFace;
        Edges[edge3]->face = newFace;
        associate_vertices(Vertices[std::get<0>(face) - 1], edge1);
        associate_vertices(Vertices[std::get<1>(face) - 1], edge2);
        associate_vertices(Vertices[std::get<2>(face) - 1], edge3);
        // perform the  connections
        if (Edges.find(std::pair(edge1.second, edge1.first)) != Edges.end())
        {
            // std::cout << "hit\n";
            Edges[edge1]->pairHalfEdge = Edges[std::pair(edge1.second, edge1.first)];
            Edges[edge1]->boundary = false;
            Edges[std::pair(edge1.second, edge1.first)]->pairHalfEdge = Edges[edge1];
            Edges[std::pair(edge1.second, edge1.first)]->boundary = false;
        }
        if (Edges.find(std::pair(edge2.second, edge2.first)) != Edges.end())
        {
            // std::cout << "hit\n";
            Edges[edge2]->pairHalfEdge = Edges[std::pair(edge2.second, edge2.first)];
            Edges[edge2]->boundary = false;
            Edges[std::pair(edge2.second, edge2.first)]->pairHalfEdge = Edges[edge2];
            Edges[std::pair(edge2.second, edge2.first)]->boundary = false;
        }
        if (Edges.find(std::pair(edge3.second, edge3.first)) != Edges.end())
        {
            // std::cout << "hit\n";
            Edges[edge3]->pairHalfEdge = Edges[std::pair(edge3.second, edge3.first)];
            Edges[edge3]->boundary = false;
            Edges[std::pair(edge3.second, edge3.first)]->pairHalfEdge = Edges[edge3];
            Edges[std::pair(edge3.second, edge3.first)]->boundary = false;
        }
        // push back faces, half edges and vertices
        HalfEdges.push_back(Edges[edge1]);
        HalfEdges.push_back(Edges[edge2]);
        HalfEdges.push_back(Edges[edge3]);
        Faces.push_back(newFace);
        face_count++;
    }
    // HalfEdge *t = Faces[0]->start_edge;
    // HalfEdge *y = t;
    // do
    // {
    //     std::cout << "VERTEX ID OF FACE :" << y->vertex->id << " \n";
    //     y = y->nextHalfEdge;
    // } while (y != t);



      if (begin_cut != NULL && last_he != NULL && begin_cut->face->id != last_he->face->id) //ideally begin_cut != NULL but this is done for simplification
    {
        std::vector<MeshFace *> touched_faces;
        t = begin_cut;
        std::cout << "begin\n";
        std::cout << "FIRST face " << begin_cut->face->id << "\n";
        std::cout << "END face " << last_he->face->id << "\n";
        HalfEdge *a, *b, *c;
        a = t;
        b = t->nextHalfEdge;
        c = t->nextHalfEdge->nextHalfEdge;
        glm::vec2 apos, bpos, cpos;
        apos = glm::vec2(a->vertex->position);
        bpos = glm::vec2(b->vertex->position);
        cpos = glm::vec2(c->vertex->position);
        std::cout << " A " << glm::to_string(apos) << "\n";
        std::cout << " B " << glm::to_string(bpos) << "\n";
        std::cout << " C " << glm::to_string(cpos) << "\n";
        bool ed1 = geometry_k::get_line_intersection(p0, p1, apos, bpos, &x1, &y1);
        bool ed2 = geometry_k::get_line_intersection(p0, p1, bpos, cpos, &x2, &y2);
        bool ed3 = geometry_k::get_line_intersection(p0, p1, cpos, apos, &x3, &y3);
        if (ed1)
        {

            std::cout << "AB intersects : " << x1 << " " << y1 << "\n";
            std::cout << "A id : " << a->id << "A pair id : " << a->pairHalfEdge->id << "\n";
            t = a->pairHalfEdge;
        }
        if (ed2)
        {
            std::cout << "BC intersects : " << x2 << " " << y2 << "\n";
            std::cout << "B id : " << b->id << "B pair id : " << b->pairHalfEdge->id << "\n";
            t = b->pairHalfEdge;
        }
        if (ed3)
        {
            std::cout << "CA intersects : " << x3 << " " << y3 << "\n";
            std::cout << "C id : " << c->id << "C pair id : " << c->pairHalfEdge->id << "\n";
            t = c->pairHalfEdge;
        }
        // t = b->pairHalfEdge;

        // std::cout << "AB " << glm::to_string(a->vertex->position) << " :: " << glm::to_string(b->vertex->position) << "\n";
        // std::cout << "BC " << glm::to_string(b->vertex->position) << " :: " << glm::to_string(c->vertex->position) << "\n";
        // std::cout << "CA " << glm::to_string(c->vertex->position) << " :: " << glm::to_string(a->vertex->position) << "\n";
        std::cout
            << " TOUCHED FACES";
        for (auto f : touched_faces)
        {
            std::cout << f->id << " ";
        }

        // do
        // {
        //     p2 = glm::vec2(t->vertex->position);
        //     p3 = glm::vec2(t->nextHalfEdge->vertex->position);
        //     float x, y;
        //     if (geometry_k::get_line_intersection(p0, p1, p2, p3, &x, &y))
        //     {
        //         std::cout << " x, y = " << x << ", " << y << "\n";
        //         int vcounter = Vertices.size();
        //         Vertices.push_back(std::move(new MeshVertex(vcounter + 1, glm::vec3(p0.x, p0.y, 0.0))));
        //         Vertices.push_back(std::move(new MeshVertex(vcounter + 2, glm::vec3(x, y, 0.0))));
        //     }
        //     t = t->nextHalfEdge;
        // } while (t != begin_cut);
    }


    /* old perform_cut*/
    void MeshHE::perform_cut(glm::vec2 p0, glm::vec2 p1)
{
    /*
    1. find which face does p0 and p1 belong to
    2. perform intersection of p0p1 and one edge of the triangle
    3. two specific cases may arise 
    4. perform half edge operations which are case specific
    */

    //1->
    HalfEdge *begin_cut = NULL;
    HalfEdge *last_he = NULL;
    glm::vec2 p2, p3;
    float x1, y1; //, x2, y2, x3, y3;
    bool check_edge1, check_edge2, check_edge3;
    determine_start_and_end_faces(begin_cut, last_he, p0, p1);
    HalfEdge *t = begin_cut;
    int vcounter = Vertices.size() + 1;                                                   // original indices
    if (begin_cut != NULL && last_he != NULL && begin_cut->face->id != last_he->face->id) //ideally begin_cut != NULL but this is done for simplification
    {
        std::map<std::pair<unsigned int, unsigned int>, HalfEdge *> temp_edge_map;

        //perform cut until currentface->face->id != last_he->face->id
        if (t->face->id == begin_cut->face->id)
        {
            HalfEdge *opp_edge1 = t->pairHalfEdge;
            HalfEdge *opp_edge2 = t->nextHalfEdge->pairHalfEdge;
            HalfEdge *opp_edge3 = t->nextHalfEdge->nextHalfEdge->pairHalfEdge;
            // save the boundary edges
            // temp_edge_map[opp_edge1->edge_pair] = NULL;
            // temp_edge_map[opp_edge2->edge_pair] = NULL;
            // temp_edge_map[opp_edge3->edge_pair] = NULL;
            if (opp_edge1 != NULL)
            {
                temp_edge_map[opp_edge1->edge_pair] = opp_edge1;
            }
            if (opp_edge2 != NULL)
            {
                temp_edge_map[opp_edge2->edge_pair] = opp_edge2;
            }
            if (opp_edge3 != NULL)
            {
                temp_edge_map[opp_edge3->edge_pair] = opp_edge3;
            }
        }
        Vertices.push_back(std::move(new MeshVertex(vcounter, glm::vec3(p0.x, p0.y, 0.0))));
        vcounter += 1;
        t->face->set_delete(); // delete the face
        t->set_delete();
        t->nextHalfEdge->set_delete();
        t->nextHalfEdge->nextHalfEdge->set_delete();
        MeshVertex *v1, *v2, *v3, *new_vert;
        // for this project vertex pointers are not important still doing it to maintain consistency
        v1 = t->vertex;
        v2 = t->nextHalfEdge->vertex;
        v3 = t->nextHalfEdge->nextHalfEdge->vertex;
        new_vert = Vertices[Vertices.size() - 1];
        // make the new half edges
        int he_count = HalfEdges.size();
        HalfEdge *broken_he1_1 = new HalfEdge(he_count);
        HalfEdge *broken_he1_2 = new HalfEdge(he_count + 1);
        HalfEdge *broken_he1_3 = new HalfEdge(he_count + 2);
        HalfEdge *broken_he2_1 = new HalfEdge(he_count + 3);
        HalfEdge *broken_he2_2 = new HalfEdge(he_count + 4);
        HalfEdge *broken_he2_3 = new HalfEdge(he_count + 5);
        HalfEdge *broken_he3_1 = new HalfEdge(he_count + 6);
        HalfEdge *broken_he3_2 = new HalfEdge(he_count + 7);
        HalfEdge *broken_he3_3 = new HalfEdge(he_count + 8);
        he_count += 9;
        //first face HE next and prev connections
        do_next_prev_connections(broken_he1_1, broken_he1_2, broken_he1_3);
        // second face HE next and prev connections
        do_next_prev_connections(broken_he2_1, broken_he2_2, broken_he2_3);
        //third face HE next and prev connections
        do_next_prev_connections(broken_he3_1, broken_he3_2, broken_he3_3);
        // v1 v2 new_vert
        int face_count = Faces.size();
        MeshFace *new_face_1 = new MeshFace(face_count);
        new_face_1->start_edge = broken_he1_1;
        broken_he1_1->face = new_face_1;
        broken_he1_2->face = new_face_1;
        broken_he1_3->face = new_face_1;
        broken_he1_1->vertex = v1;
        broken_he1_2->vertex = v2;
        broken_he1_3->vertex = new_vert;
        broken_he1_1->edge_pair = std::make_pair(v1->id, v2->id);
        broken_he1_2->edge_pair = std::make_pair(v2->id, new_vert->id);
        broken_he1_3->edge_pair = std::make_pair(new_vert->id, v1->id);
        temp_edge_map[std::make_pair(v1->id, v2->id)] = broken_he1_1;
        temp_edge_map[std::make_pair(v2->id, new_vert->id)] = broken_he1_2;
        temp_edge_map[std::make_pair(new_vert->id, v1->id)] = broken_he1_3;
        assign_opposite_he(temp_edge_map, broken_he1_1);
        assign_opposite_he(temp_edge_map, broken_he1_2);
        assign_opposite_he(temp_edge_map, broken_he1_3);
        // v3 v1 new_vert
        MeshFace *new_face_2 = new MeshFace(face_count + 1);
        new_face_2->start_edge = broken_he2_1;
        broken_he2_1->face = new_face_2;
        broken_he2_2->face = new_face_2;
        broken_he2_3->face = new_face_2;
        broken_he2_1->vertex = v3;
        broken_he2_2->vertex = v1;
        broken_he2_3->vertex = new_vert;
        broken_he2_1->edge_pair = std::make_pair(v3->id, v1->id);
        broken_he2_2->edge_pair = std::make_pair(v1->id, new_vert->id);
        broken_he2_3->edge_pair = std::make_pair(new_vert->id, v3->id);
        temp_edge_map[std::make_pair(v3->id, v1->id)] = broken_he2_1;
        temp_edge_map[std::make_pair(v1->id, new_vert->id)] = broken_he2_2;
        temp_edge_map[std::make_pair(new_vert->id, v3->id)] = broken_he2_3;
        assign_opposite_he(temp_edge_map, broken_he2_1);
        assign_opposite_he(temp_edge_map, broken_he2_2);
        assign_opposite_he(temp_edge_map, broken_he2_3);
        // v2 v3 new_vert
        MeshFace *new_face_3 = new MeshFace(face_count + 3);
        new_face_3->start_edge = broken_he3_1;
        broken_he3_1->face = new_face_3;
        broken_he3_2->face = new_face_3;
        broken_he3_3->face = new_face_3;
        broken_he3_1->vertex = v2;
        broken_he3_2->vertex = v3;
        broken_he3_3->vertex = new_vert;
        broken_he3_1->edge_pair = std::make_pair(v2->id, v3->id);
        broken_he3_2->edge_pair = std::make_pair(v3->id, new_vert->id);
        broken_he3_3->edge_pair = std::make_pair(new_vert->id, v2->id);
        temp_edge_map[std::make_pair(v2->id, v3->id)] = broken_he3_1;
        temp_edge_map[std::make_pair(v3->id, new_vert->id)] = broken_he3_2;
        temp_edge_map[std::make_pair(new_vert->id, v2->id)] = broken_he3_3;
        assign_opposite_he(temp_edge_map, broken_he3_1);
        assign_opposite_he(temp_edge_map, broken_he3_2);
        assign_opposite_he(temp_edge_map, broken_he3_3);
        //add back new faces and new halfedges
        face_count += 3;
        Faces.push_back(new_face_1);
        Faces.push_back(new_face_2);
        Faces.push_back(new_face_3);
        HalfEdges.push_back(broken_he1_1);
        HalfEdges.push_back(broken_he1_2);
        HalfEdges.push_back(broken_he1_3);
        HalfEdges.push_back(broken_he2_1);
        HalfEdges.push_back(broken_he2_2);
        HalfEdges.push_back(broken_he2_3);
        HalfEdges.push_back(broken_he3_1);
        HalfEdges.push_back(broken_he3_2);
        HalfEdges.push_back(broken_he3_3);
        bool stop_flag = false;
        // begin cut
        HalfEdge *save_temp = NULL;
        int c = 0;
        for (auto &tem : temp_edge_map)
        {
            HalfEdge *t = tem.second;
            if (t->pairHalfEdge != NULL && t->pairHalfEdge->face->id == last_he->face->id)
            {
                stop_flag = true;
            }
            if (!(t->deleted))
            {
                HalfEdge *tnext = t->nextHalfEdge;
                HalfEdge *tnextnext = t->nextHalfEdge->nextHalfEdge;
                p2 = glm::vec2(t->vertex->position);
                p3 = glm::vec2(tnext->vertex->position);
                if (geometry_k::get_line_intersection(p0, p1, p2, p3, &x1, &y1))
                {
                    c++;
                    save_temp = t;
                    save_temp->face->set_delete(); // delete face 1
                    save_temp->pairHalfEdge->set_delete();
                    save_temp->set_delete(); // delete face 1
                    save_temp->pairHalfEdge->face->set_delete();
                    if (save_temp->pairHalfEdge != NULL)
                    {
                    }

                    Vertices.push_back(std::move(new MeshVertex(vcounter, glm::vec3(x1, y1, 0.0))));
                    vcounter++;
                    break;
                }
            }
        }
        assert(c == 1);
        if (save_temp != NULL)
        {
            std::cout << "TEM ID " << save_temp->id << "\n";
            std::cout << "No of times " << c << "\n";
        }
    }
}